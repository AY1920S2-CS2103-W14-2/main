= InventoryManager v1.4 - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S2-CS2103-W14-2/main/tree/master

By: `AY1920S2-CS2103-W14-2`      Since: `Feb 2020`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete-s 1`.

.Component interactions for `delete-s 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `SupplierListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `InventoryManagerParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a supplier).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("buy g/Apple q/50")` API call.

.Interactions Inside the Logic Component for the `buy g/Apple q/50` Command
image::BuySequenceDiagram.png[]

NOTE: The lifeline for `BuyCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the 3 sets of data: `AddressBook`, `Inventory` and `TransactionHistory`.
* these 3 sets of data stores `Supplier`, `Good` and `Transaction` respectively.
* have close interaction between each other through various commands input.
* exposes 3 sets of  unmodifiable list: `ObservableList<Supplier>`, `ObservableList<Good>` and `ObservableList<Transaction>` that can be 'observed' as 3 separate panels on the UI. e.g. the UI can be bound to this list so that the UI automatically updates when any of the data in the list change.
* does not depend on any of the other three components.

The `Supplier`,

* stores details of supplier: `Name`, `Phone`, `Address`, `Email` and `Offer`.
* can have no `Offer` or multiple `Offer`.
* each offer consists of `GoodName` and `Price`, indicating the supplier offer to sell a specific good with a specific price.

image:SupplierModelClassDiagram.png[]


The `Good`,

* stores details of good: `GoodName`, `Quantity` and `ThresholdQuantity`.

image:GoodModelClassDiagram.png[]

The `Transaction`,

* stores details of transaction: `TransactionId`, `Good` and `Quantity`.
* differentiate by two types: `SellTransaction` and `BuyTransaction`.
* `SellTransaction` stores additional detail: `Price` which is selling price of the good.
* `BuyTransaction` stores additional details: `Price` and `Supplier`, which are the buying price of the good and the seller of the good respectively.

image:TransactionModelClassDiagram.png[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save 3 sets of data: `AddressBook`, `Inventory` and `TransactionHistory` in json format, save them in separate json file and read the data back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== Undo/Redo feature
==== Implementation

The undo/redo mechanism is facilitated by `VersionedInventory`, `VersionedAddressBook` and `VersionedTransactionHistory`
for `Good`, `Supplier` and `Transaction` data respectively. These versioned classes extend their non-versioned
counterparts. These classes also implement the `Versionable` interface, which has these methods:

* `Versionable#commit()` -- Adds the current state to the tracked states.
* `Versionable#undo()` -- Restores the previous database state.
* `Versionable#redo()` -- Restores the most recently undone database state.

These operations are exposed in the `Model` interface, which extends `Versionable` as well.
Each call of these methods will call the respective methods of each of the versioned classes.

The class diagram below shows how the classes are related to each other.

image::VersionClassDiagram.png[]

The three versioned classes use the same logic for versioning, so only `VersionedInventory` will be mentioned in
subsequent examples and diagrams.

Currently, `VersionedInventory` uses `LinearHistory<Inventory>` for versioning, and delegates all `Versionable` methods
to it. `LinearHistory<Inventory>` stores Inventory, which has implemented the `Copyable<Inventory>` interface to allow
creation of independent copies for storage. On the other hand, `LinearHistory` implements the interface
`Version<Inventory>`, which extends from `Versionable` and has the following additional method:

* `Version#getCurrentState()` -- Returns the current state of the stored object

The class diagram below shows how the classes are connected such that `VersionedInventory` is able to use
`LinearHistory<Inventory>`.

image::LinearHistoryClassDiagram.png[]

The sequence diagram below illustrates the events that occur when a user calls the undo command assuming that there is
a state to return to.

image::UndoSequenceDiagram.png[]

NOTE: The lifeline for `UndoCommand` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user launches the application for the first time. For each category, the `VersionedDatabaseManager` will be initialized with the respective initial database state, with the `currentStatePointer` pointing to that single database state.

image::UndoRedoState0.png[]

Step 2. The user executes `delete-s 5` command to delete the 5th supplier in the supplier list. The `delete-s` command calls `Model#commit()` since it modifies the database, causing the database state after the `delete-s 5` command executes to be saved in the `databaseStateList`, and the `currentStatePointer` is shifted to the newly inserted database state. This also applies to the `VersionedDatabase` for `Good` and `Transaction` even if there are no changes to them.

image::UndoRedoState1.png[]

Step 3. The user executes `add-s n/David ...` to add a new supplier. The `add-s` command also calls `Model#commit()` as it modifies the database, causing another modified database state to be saved into the `databaseStateList`.

image::UndoRedoState2.png[]

[NOTE]
If a command fails its execution, it will not call `Model#commit()`, so the database state will not be saved into the `databaseStateList`.

Step 4. The user now decides that adding the supplier was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undo()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous database state, and restores the database to that state.

image::UndoRedoState3.png[]

[NOTE]
If the `currentStatePointer` is at index 0, pointing to the initial database state, then there are no previous database states to restore. The `undo` command uses `Model#canUndo()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

The `redo` command does the opposite -- it calls `Model#redo()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the database to that state.

[NOTE]
If the `currentStatePointer` is at index `databaseList.size() - 1`, pointing to the latest database state, then there are no undone database states to restore. The `redo` command uses `Model#canRedo()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

Step 5. The user then decides to execute the command `list-s`. Commands that do not modify any database, such as `list-s`, will usually not call `Model#commit()`, `Model#undo()` or `Model#redo()`. Thus, the `databaseStateList` remains unchanged.

image::UndoRedoState4.png[]

Step 6. The user executes `clear-s`, which calls `Model#commit()`. Since there is a branching in history, all database states after the `currentStatePointer` will be purged. This prevents conflicts from redoing commands from a diverged history e.g. editing a supplier named Jane when Jane was deleted in the new history. Furthermore, there are many mainstream editing software that exhibits this behaviour.

image::UndoRedoState5.png[]

==== Design Considerations

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire databases.
** Pros: Trivial implementation.
** Cons: May encounter performance issues due to memory load, especially with three different databases.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete-s`, just save the supplier being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.

===== Aspect: When to save history

* **Alternative 1 (current choice) :** Save all three databases even when only one database is modified.
** Pros: Easy to implement.
** Cons: Inefficient memory usage, especially when only one database is being modified in each action.
* **Alternative 2:** Save a database only when that database is modified.
** Pros: Saves memory usage that could be used for performance.
** Cons: Requires information on which databases are affected by a command, which breaks abstraction on both the VersionedDatabase and commands.

===== Aspect: How storage of states is implemented

* **Alternative 1 (current choice) :** Store states as objects during Java runtime
** Pros: Simple implementation and automatic cleanup.
** Cons: Segmentation fault may occur for very long sessions and large databases.
* **Alternative 2:** Store states in an external file
** Pros: Less memory usage, leading to better performance.
** Cons: File I/O may incur comparable overhead for smaller databases, and abrupt termination of the application may result in temporary files being left behind and cluttering space.
// end::undoredo[]

// tag::dataencryption[]
=== Data Encryption
==== Proposed Implementation
The data encryption adn decryption mechanism is facilitated by `FileCryptoUtil`. The crypto algorithm employed is Advanced
Encryption Standard (AES) under symmetric encryption algorithm, where both the encryption and decryption uses same key.

`FileCryptoUtil` will implement the following operations:
`FileCryptoUtil#encryptFile()` -- encrypts human readable Json file into unreadable encrypted file.
`FileCryptoUtil#decryptFile()` -- decrypts unreadable file back to readable json file.

These methods are public static and are exposed to all for now.

Given below is an example on how the encryption and decryption behave at each step.

** *Encryption*:

Whenever the user enters a valid command, under the `LogicManager#execute()`, the data is firstly convert to JsonAdaptedObject and stored in a Json file.
Next, `FileCryptoUtil#encryption()` is called. A cipher will be initiated based on the specific SecretKey,
 the algorithm used for encryption, and the transformation of the data.
The data in the json file will be read by bit and encrypted to unreadable format. The encrypted data is then stored in the encrypted file.

[NOTE]
If the command cannot be executed successfully in `LogicManager#execute()`, then exception will be thrown before `FileCryptoUtil#encryption()`,
 and the encryption will not be activated.

** *Decryption* :

When the user launches the application. `FileCryptoUtil#decryption()` will be called before the reading Json file into `StorageManager`.
A cipher will be initiated based on same SecretKey, algorithm and transformation used in the encryption of the data.
The data in the encrypted file is then read by bit and decrypted by the cipher into readable Json format.
The readable Json data is then stored in the Json file, which can be read by `JsonUtil#readJsonFile()` to JsonAdaptedObject.

==== Design Considerations

===== Aspect: Key management for cipher

* **Alternative 1 (current choice):** Set a default key within the application.
** Pros: Easy to implement.
** Cons: Key cannot be changed, expose to possible brute force attack.
* **Alternative 2:** Set password requirement for the application and use password use the key.
** Pros: User can change the key regularly, which strengthen data security.
** Cons: Hard to implement to password feature. The password has to be further strengthen by PBKDF2 to enhance the complexity of the key.

// end::dataencryption[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* has a need to manage a large number of <<fast-moving-consumer-goods, fast-moving consumer goods (FMCG)>> which arrives in batches
* has a need to manage a large number of suppliers
* has a need to draw insights from analysing transactions with suppliers and customers
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: manage an FMCG store faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use InventoryManager

|`* * *` |user |add a new supplier |

|`* * *` |user |add a new goods to supplier|

|`* * *` |user |delete a supplier |remove entries that I no longer need

|`* * *` |user |see goods that are low in stock |know what to buy

|`* * *` |user |see goods that are low in stock |buy more before running out

|`* * *` |user |update inventory with the <<transaction-record, transaction records>> |avoid keeping track of the inventory personally

|`* * *` |user |update prices of goods offered by suppliers |account for changes in supply agreement or prices

|`* * *` |clumsy user |undo previous actions |fix mistakes in inputs or spelling

|`* * *` |user |be notified of goods falling below a set quantity threshold |buy expected goods in advance

|`* * *` |user |be notified of goods that are above a set quantity threshold |avoid expiration of large number of goods

|`* *` |user |create a set purchase order automatically on a regular basis |simulate supply contracts

|`* *` |user |find a supplier by goods sold |locate the relevant suppliers without having to go through the entire list

|`* *` |user |find a goods by name |locate the relevant goods without having to go through the entire list

|`* *` |user |hide transaction details by default |minimize chance of someone else seeing them by accident

|`* *` |user |set expiry event for a batch of goods |account for expiration of goods

|`* *` |user |change names of goods |avoid confusion when producers change the name of their products

|`* *` |user |have a summary of the transactions throughout the day |determine performance of the day

|`* *` |expanding user |see a performance tracker |find points of improvement in business activity

|`*` |clumsy user |receive suggestion for the next words |avoid misspelling and be reminded of syntax

|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `InventoryManager` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
:numbered!:
=== Use case: UC1 - listing all suppliers

*MSS*

1.  User requests to list suppliers.
2.  InventoryManager shows a list of suppliers.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
[none]
** 2a1. InventoryManager shows a message to inform that there are no suppliers.
+
Use case ends.

=== Use case: UC2 - listing all goods

*MSS*

1.  User requests to list goods.
2.  InventoryManager shows a list of goods.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
[none]
** 2a1. InventoryManager shows a message to inform that there are no goods.
+
Use case ends.

=== Use case: UC3 - adding a supplier

*MSS*

1.  User requests to add a supplier with given details.
2.  InventoryManager creates a supplier with the given details.
+
Use case ends.

*Extensions*

[none]
* 1a. The given details of the supplier is incomplete.
+
[none]
** 1a1. Inventory Manager shows an error message to indicate the incomplete details.
+
Use case ends.

[none]
* 1b. The given details of the supplier is invalid.
+
[none]
** 1b1. Inventory Manager shows an error message to indicate the invalid details.
+
Use case ends.

[none]
* 1c. The given details contains a non-supported parameter e.g. age.
+
[none]
** 1c1. Inventory Manager shows an error message to indicate the non-supported parameter.
+
Use case ends.

[none]
* 1d. The specified supplier already exists.
+
[none]
** 1d1. Inventory Manager shows an error message to indicate that the supplier already exists.
+
Use case ends.

=== Use case: UC4 - deleting a supplier

*MSS*

1.  User [.underline]#lists all suppliers (UC1).#
2.  User selects a supplier from the list and requests to delete the supplier by the index shown on the list.
3.  InventoryManager deletes the supplier.
+
Use case ends.

*Extensions*

[none]
* 1a. The list is empty.
+
[none]
** Use case ends.

[none]
* 2a. The given index is invalid.
+
[none]
** 2a1. InventoryManager shows an error message to indicate the invalid index.
+
Use case ends.

=== Use case: UC5 - deleting a good from supplier's list

*MSS*

1.  User lists all suppliers (UC1).
2.  User requests to delete a good from a supplier's list and give the good's name.
2.  InventoryManager confirms the deletion.
3.  InventoryManager deletes the good from the supplier's good list.
+
Use case ends.

*Extensions*

1.  The required good is not found.
** InventoryManager informs there is no such good found.
+
Use case ends.


=== Use case: UC6 - editing a supplier

*MSS*

1.  User lists all suppliers (UC1)
2.  User requests to edit a supplier specified by the index and gives the new parameters
3.  InventoryManager updates the details of the supplier.
+
Use case ends.

*Extensions*

1.  There is existing good in the list.
** The latest information of good will be updated.
+
Use case ends.

2.  The given index is invalid.
** InventoryManager shows an error message to indicate the invalid index.
+
Use case ends.

3.  The given details of the supplier is incomplete.
** Inventory Manager shows an error message to indicate the incomplete details.
+
Use case ends.

4.  The given details of the supplier is invalid.
** Inventory Manager shows an error message to indicate the invalid details.
+
Use case ends.

5.  The given details contains a non-supported parameter e.g. age.
** Inventory Manager shows an error message to indicate the non-supported parameter.
+
Use case ends.

6.  The good is not found in the existing supplier's good list.
** Inventory Manager will include the good as a new good in the supplier's good list.
+
Use case ends.

=== Use case: UC7 - finding a supplier for a particular goods

*MSS*

1.  User [.underline]#lists all goods (UC2).#
2.  User requests to list the suppliers supplying the goods with a specified name.
3.  InventoryManager shows a list of suppliers providing this goods.
+
Use case ends.

*Extensions*

[none]
* 1a. The list is empty.
+
[none]
** Use case ends.

[none]
* 2a. The goods with the given name does not exist.
+
[none]
** 2a1. InventoryManager shows an error message to indicate the goods does not exist.
+
Use case ends.

[none]
* 3a. The list is empty.
+
[none]
** 3a1. InventoryManager informs the user that there are no suppliers providing this goods.
+
Use case ends.

=== Use case: UC8 - buying a particular goods

*MSS*

1.  User [.underline]#lists all the suppliers for a particular good (UC7).#
2.  User requests to make a buy order for a quantity of the particular goods from a supplier.
3.  InventoryManager adds the order and adds the quantity to the total number of that particular goods.
+
Use case ends.

*Extensions*

[none]
* 1a. The list is empty.
+
[none]
** Use case ends.

[none]
* 2a. The goods with the given name does not exist.
+
[none]
** 2a1. InventoryManager shows an error message to indicate the goods does not exist.
+
Use case ends.

[none]
* 2b. The supplier with the given name does not exist.
+
[none]
** 2b1. InventoryManager shows an error message to indicate the supplier does not exist.
+
Use case ends.

[none]
* 2c. The quantity given is invalid.
+
[none]
** 2c1. InventoryManager shows an error message to indicate the quantity is invalid.
+
Use case ends.

[none]
* 2d. One or more parameters are missing.
+
[none]
** 2d1. InventoryManager shows an error message to indicate the missing parameters.
+
Use case ends.

=== Use case: UC9 - selling a particular goods

*MSS*

1.  User [.underline]#lists all goods (UC2).#
2.  User requests to make a selling order of a quantity of a particular goods.
3.  InventoryManager adds the sell order and deducts the quantity in the selling order to the total number of the particular goods.
+
Use case ends.

*Extensions*

[none]
* 1a. The list is empty.
+
[none]
** Use case ends.

[none]
* 2a. The goods with the given name does not exist.
+
[none]
** 2a1. InventoryManager shows an error message to indicate the goods does not exist.
+
Use case ends.

[none]
* 2b. The quantity given is invalid.
+
[none]
** 2b1. InventoryManager shows an error message to indicate the quantity is invalid.
+
Use case ends.

[none]
* 2c. The quantity given exceeds current amount in inventory.
+
[none]
** 2c1. InventoryManager shows an error message to indicate insufficient quantity.
+
Use case ends.

[none]
* 2d. One or more parameters are missing.
+
[none]
** 2d1. InventoryManager shows an error message to indicate the missing parameters.
+
Use case ends.

=== Use case: UC10 - set lower threshold quantity of goods

*MSS*

1.  User [.underline]#lists all goods (UC2).#
2.  User sets a lower quantity threshold for a particular goods.
+
Use case ends.

*Extensions*

[none]
* 1a. The list is empty.
+
[none]
** Use case ends.

[none]
* 2a. The quantity is invalid.
[none]
** 2a1. InventoryManager shows an error message to indicate the quantity is invalid.
+
Use case ends.

[none]
* 2b. The quantity is above the upper threshold, if it exists.
[none]
** 2b1. InventoryManager shows an error message to indicate the quantity is above the upper threshold.
+
Use case ends.

[none]
* 2c. The given index is out of bounds.
[none]
** 2c1. InventoryManager shows an error message to indicate the index is out of bounds.
+
Use case ends.

=== Use case: UC11 - listing all past transactions

*MSS*

1.  User requests to list all past transactions.
2.  InventoryManager lists all past transactions.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
[none]
** 2a1. InventoryManager informs the user that there are no past transactions.
+
Use case ends.

=== Use case: UC12 - search transactions with specific criteria

*MSS*

1.  User requests to find transactions with the specific criteria.
2.  InventoryManager lists all transactions fulfill the specific criteria.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
[none]
** 2a1. InventoryManager informs the user that there are no transactions.
+
Use case ends.

[none]
* 2b. Any of the criteria is in invalid format
[none]
** 2b1. InventoryManager informs the user that the criteria input is invalid.
+
Use case ends.

=== Use case: UC13 - undoing a command

*MSS*

1.  User enters the undo command through the command line.
2.  InventoryManager moves to the state before the latest modifying command e.g. add supplier.
3.  InventoryManager shows a message indicating success.
+
Use case ends.

*Extensions*

[none]
* 2a. InventoryManager is at the oldest recorded state and thus is unable to move to a previous state.
+
[none]
** 2a1. InventoryManager informs the user that it is unable to undo from the oldest recorded state.
+
Use case ends.

=== Use case: UC14 - redoing a command

*MSS*

1.  User enters the redo command through the command line.
2.  InventoryManager moves to the state before the latest undo command.
3.  InventoryManager shows a message indicating success.
+
Use case ends.

*Extensions*

[none]
* 2a. InventoryManager is unable to move to the next state as it is already at the latest state.
+
[none]
** 2a1. InventoryManager informs the user that it is unable to redo from the latest state.
+
Use case ends.

:numbered:

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 suppliers and goods without a noticeable sluggishness in performance for typical usage.
.  Should run without any internet connection.
.  Should have a human-editable storage text file.
.  Should not require a database.
.  Should not require an installer to use.
.  Should not exceed 100MB in application size.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.

[appendix]
== Glossary
[[fast-moving-consumer-goods]] Fast-moving consumer goods::
Goods that are characterised by large inventory quantities, high turnover rate, numerous suppliers and short shelf-life.

[[transaction-record]] Transaction record::
A record of an event that results in change in the quantity of goods i.e. buying/selling.

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X.

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a supplier

. Deleting a supplier while all suppliers are listed

.. Prerequisites: List all suppliers using the `list` command. Multiple suppliers in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No supplier is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
